when flag clicked
set [ADDRESSING v] to [\["imp", "inx", "   ", "   ", "   ", "zp",  "zp",  "   ", "imp", "imm", "acc", "   ", "   ", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "   ", "zpx", "zpx", "   ", "imp", "aby", "   ", "   ", "   ", "abx", "abx", "   ", "abs", "inx", "   ", "   ", "zp",  "zp",  "zp",  "   ", "imp", "imm", "acc", "   ", "abs", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "   ", "zpx", "zpx", "   ", "imp", "aby", "   ", "   ", "   ", "abx", "abx", "   ", "imp", "inx", "   ", "   ", "   ", "zp",  "zp",  "   ", "imp", "imm", "acc", "   ", "abs", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "   ", "zpx", "zpx", "   ", "imp", "aby", "   ", "   ", "   ", "abx", "abx", "   ", "imp", "inx", "   ", "   ", "   ", "zp",  "zp",  "   ", "imp", "imm", "acc", "   ", "ind", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "   ", "zpx", "zpx", "   ", "imp", "aby", "   ", "   ", "   ", "abx", "abx", "   ", "   ", "inx", "   ", "   ", "zp",  "zp",  "zp",  "   ", "imp", "   ", "imp", "   ", "abs", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "zpx", "zpx", "zpy", "   ", "imp", "aby", "imp", "   ", "   ", "abx", "   ", "   ", "imm", "inx", "imm", "   ", "zp",  "zp",  "zp",  "   ", "imp", "imm", "imp", "   ", "abs", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "zpx", "zpx", "zpy", "   ", "imp", "aby", "imp", "   ", "abx", "abx", "aby", "   ", "imm", "inx", "   ", "   ", "zp",  "zp",  "zp",  "   ", "imp", "imm", "imp", "   ", "abs", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "   ", "zpx", "zpx", "   ", "imp", "aby", "   ", "   ", "   ", "abx", "abx", "   ", "imm", "inx", "   ", "   ", "zp",  "zp",  "zp",  "   ", "imp", "imm", "imp", "   ", "abs", "abs", "abs", "   ", "rel", "iny", "   ", "   ", "   ", "zpx", "zpx", "   ", "imp", "aby", "   ", "   ", "   ", "abx", "abx", "   "\]]
set [OPCODES v] to [\["brk", "ora", "   ", "   ", "   ", "ora", "asl", "   ", "php", "ora", "asl", "   ", "   ", "ora", "asl", "   ", "bpl", "ora", "   ", "   ", "   ", "ora", "asl", "   ", "clc", "ora", "   ", "   ", "   ", "ora", "asl", "   ", "jsr", "and", "   ", "   ", "bit", "and", "rol", "   ", "plp", "and", "rol", "   ", "bit", "and", "rol", "   ", "bmi", "and", "   ", "   ", "   ", "and", "rol", "   ", "sec", "and", "   ", "   ", "   ", "and", "rol", "   ", "rti", "eor", "   ", "   ", "   ", "eor", "lsr", "   ", "pha", "eor", "lsr", "   ", "jmp", "eor", "lsr", "   ", "bvc", "eor", "   ", "   ", "   ", "eor", "lsr", "   ", "cli", "eor", "   ", "   ", "   ", "eor", "lsr", "   ", "rts", "adc", "   ", "   ", "   ", "adc", "ror", "   ", "pla", "adc", "ror", "   ", "jmp", "adc", "ror", "   ", "bvs", "adc", "   ", "   ", "   ", "adc", "ror", "   ", "sei", "adc", "   ", "   ", "   ", "adc", "ror", "   ", "   ", "sta", "   ", "   ", "sty", "sta", "stx", "   ", "dey", "   ", "txa", "   ", "sty", "sta", "stx", "   ", "bcc", "sta", "   ", "   ", "sty", "sta", "stx", "   ", "tya", "sta", "txs", "   ", "   ", "sta", "   ", "   ", "ldy", "lda", "ldx", "   ", "ldy", "lda", "ldx", "   ", "tay", "lda", "tax", "   ", "ldy", "lda", "ldx", "   ", "bcs", "lda", "   ", "   ", "ldy", "lda", "ldx", "   ", "clv", "lda", "tsx", "   ", "ldy", "lda", "ldx", "   ", "cpy", "cmp", "   ", "   ", "cpy", "cmp", "dec", "   ", "iny", "cmp", "dex", "   ", "cpy", "cmp", "dec", "   ", "bne", "cmp", "   ", "   ", "   ", "cmp", "dec", "   ", "cld", "cmp", "   ", "   ", "   ", "cmp", "dec", "   ", "cpx", "sbc", "   ", "   ", "cpx", "sbc", "inc", "   ", "inx", "sbc", "nop", "   ", "cpx", "sbc", "inc", "   ", "beq", "sbc", "   ", "   ", "   ", "sbc", "inc", "   ", "sed", "sbc", "   ", "   ", "   ", "sbc", "inc", "   "\]]
set [BYTEORDER v] to [little]
set [PAGE_WRAPPING_BUG v] to <false>
set [ROM_START] to [32768] //{"newRow":true, "comment": "Shouldn't be at most 61440"}

when [space v] key pressed
set runtime var [memory] to (M___init__ [{"49152": 162, "49153": 0, "49154": 224, "49155": 69, "49156": 240, "49157": 4, "49158": 232, "49159": 76, "49160": 2, "49161": 192, "49162": 0, "65532": 0, "65533": 192}])
set runtime var [cpu] to (P___init__ (runtime var [memory]))
say (P_execute (runtime var [cpu]) [5]) //{"newRow":true}

define M___init__ (rom) //{"blockType":"textReporter"}
set runtime var [mself] to [{}]
set [mself] . [size] to [65535]
set [mself] . [memory] to (rom::custom)
return (runtime var [mself])

define M___getitem__(mself) (address) //{"blockType":"textReporter"}
set runtime var [mself] to (mself::custom)
if <json (get [mself] . [memory]) has key (address::custom)> then
    return (get (address::custom) from (get [mself] . [memory]))
else
    return [0]

define M___setitem__(mself) (address) (value) //{"blockType":"textReporter"}
set runtime var [mself] to (mself::custom)
if <(address::custom) < (ROM_START)> then
    set [mself] . [memory] to (  set (address::custom) to (value::custom) in (get [mself] . [memory])  ) //{"newRow":true}
end
return (runtime var [mself])

define array1 (a) //{"blockType":"textReporter"}
return (in array [\[\]] add (a::custom))

define array2 (a) (b) //{"blockType":"textReporter"}
return (in array (in array [\[\]] add (a::custom)) add (b::custom))

define array3 (a) (b) (c) //{"blockType":"textReporter"}
return (in array (in array (in array [\[\]] add (a::custom)) add (b::custom)) add (c::custom))

define get (var) . (key) //{"blockType":"textReporter"}
return (get (key::custom) from (runtime var (var::custom)))

define set (var) . (key) to (value)
set runtime var (var::custom) to (set (key::custom) to (value::custom) in (runtime var (var::custom)))

define change (var) . (key) by (value)
set (var::custom) . (key::custom) to ((get (key::custom) from (runtime var (var::custom))) + (value::custom))

define change (var) . (key) within 8 bits by (value)
set (var::custom) . (key::custom) to (((get (key::custom) from (runtime var (var::custom))) + (value::custom)) and [255])

define change (var) . (key) within 16 bits by (value)
set (var::custom) . (key::custom) to (((get (key::custom) from (runtime var (var::custom))) + (value::custom)) and [65535])

define set2 (var1) (var2) to (value)
set runtime var (var1::custom) to (in array (value::custom) get [0])
set runtime var (var2::custom) to (in array (value::custom) get [1])

define set3 (var1) (var2) (var3) to (value)
set runtime var (var1::custom) to (in array (value::custom) get [0])
set runtime var (var2::custom) to (in array (value::custom) get [1])
set runtime var (var3::custom) to (in array (value::custom) get [2])

define set4 (var1) (var2) (var3) (var4) to (value)
set runtime var (var1::custom) to (in array (value::custom) get [0])
set runtime var (var2::custom) to (in array (value::custom) get [1])
set runtime var (var3::custom) to (in array (value::custom) get [2])
set runtime var (var4::custom) to (in array (value::custom) get [3])

define help_bcd_to_decimal (bcd) //{"blockType":"textReporter"}
return (  (((bcd::custom) >> [4]) * [10]) + ((bcd::custom) and [15])  )

define help_decimal_to_bcd (decimal) //{"blockType":"textReporter"}
return (  (([floor v] of ((decimal::custom) / [10])) \<\< [4]) or ((decimal::custom) mod [10])  )

define help_is_greater_equal (a) (b) <bcd> //{"blockType":"booleanReporter"}
if <bcd::custom> then
    return <(help_decimal_to_bcd (a::custom)) \>= (help_decimal_to_bcd (b::custom))>
else
    return <(a::custom) \>= (b::custom)>

define help_twos_complement (num) //{"blockType":"textReporter"}
return (if <(num::custom) \>= [128]> then ((num::custom) - [256]) else (num::custom)) //{"newRow":true}

define P___init__(memory) //{"blockType":"textReporter", "comment": "Initialize the processor."}
set runtime var [self] to [{}]
set [self] . [memory] to (memory::custom)
set [self] . [reg_a] to [0]
set [self] . [reg_x] to [0]
set [self] . [reg_y] to [0]
set [self] . [flag_c] to <false>
set [self] . [flag_z] to <false>
set [self] . [flag_v] to <false>
set [self] . [flag_n] to <false>
set2 [self] [_] to (P_reset (runtime var [self]))
return (runtime var [self])

define P_reset(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [program_counter] to (P_read_word (runtime var [self]) [65532] <false>) // 0xFFFC-0xFFFD
set [self] . [program_counter] to (runtime var [program_counter])
set [self] . [stack_pointer] to [253] // 0xFD
set [self] . [instructions] to [0]
set [self] . [flag_i] to <true>
set [self] . [flag_d] to <false>
return (array2 (runtime var [self]) [null])

define P_fetch_byte(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [data] to (P_read_byte (runtime var [self]) (get [self] . [program_counter]))
change [self] . [program_counter] within 16 bits by [1]
return (array2 (runtime var [self]) (runtime var [data]))

define P_fetch_word(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [data] to (P_read_word (runtime var [self]) (get [self] . [program_counter]) <false>)
change [self] . [program_counter] within 16 bits by [2]
return (array2 (runtime var [self]) (runtime var [data]))

define P_read_byte(self) (address) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set runtime var [data] to (M___getitem__ (get [self] . [memory]) (address::custom))
return (array2 (runtime var [self]) (runtime var [data]))

define P_read_word(self) (address) <page_wrapping_bug> //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
if <<(page_wrapping_bug::custom)> and <  ((address::custom) and [255]) = [255]>  > then // 0xFF = 255
    set runtime var [second_address] to ((address::custom) and [65280]) // 0xFF00 = 65280
else
    set runtime var [second_address] to (((address::custom) + [1]) and [65535]) // 0xFFFF = 65535
end
set2 [self] [t1] to (P_read_byte (runtime var [self]) (address::custom))
set2 [self] [t2] to (P_read_byte (runtime var [self]) (runtime var [second_address]))
if <(BYTEORDER) = [little]> then
    set runtime var [data] to (  (runtime var [t1]) or ((runtime var [t2]) \<\< [8])  )
else
    set runtime var [data] to (  ((runtime var [t1]) \<\< [8]) or (runtime var [t2])  )
end
return (array2 (runtime var [self]) (runtime var [data]))

define P_write_byte(self) (address) (value) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set [self] . [memory] to (M___setitem__ (get [self] . [memory]) (address::custom) ((value::custom) and [255]) )
return (array2 (runtime var [self]) [null])

define P_write_word(self) (address) (value) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
if <(BYTEORDER) = [little]> then
    set runtime var [value1] to ((value::custom) and [255])
    set runtime var [value2] to (((value::custom) >> [8]) and [255])
else
    set runtime var [value1] to (((value::custom) >> [8]) and [255])
    set runtime var [value2] to ((value::custom) and [255])
end
set2 [self] [_] to (P_write_byte (runtime var [self]) (address::custom) (runtime var [value1]))
set2 [self] [_] to (P_write_byte (runtime var [self]) (((address::custom)+[1]) and [65535]) (runtime var [value2]))
return (array2 (runtime var [self]) [null])

define P_read_flags_register(self) <flag_b> //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set runtime var [data] to [0]
set runtime var [data] to (  (runtime var [data]) or (if <(get [self] . [flag_n])> then [128] else [0])  )
set runtime var [data] to (  (runtime var [data]) or (if <(get [self] . [flag_v])> then  [64] else [0])  )
set runtime var [data] to (  (runtime var [data]) or (if <flag_b::custom         > then  [16] else [0])  )
set runtime var [data] to (  (runtime var [data]) or (if <(get [self] . [flag_d])> then   [8] else [0])  )
set runtime var [data] to (  (runtime var [data]) or (if <(get [self] . [flag_i])> then   [4] else [0])  )
set runtime var [data] to (  (runtime var [data]) or (if <(get [self] . [flag_z])> then   [2] else [0])  )
set runtime var [data] to (  (runtime var [data]) or (if <(get [self] . [flag_c])> then   [1] else [0])  )
return (array2 (runtime  var [self]) (runtime var [data]))

define P_set_flags_register(self) (data) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set [self] . [flag_n] to <(((data::custom) >> [7]) and [1])>
set [self] . [flag_v] to <(((data::custom) >> [6]) and [1])>
set [self] . [flag_d] to <(((data::custom) >> [3]) and [1])>
set [self] . [flag_i] to <(((data::custom) >> [2]) and [1])>
set [self] . [flag_z] to <(((data::custom) >> [1]) and [1])>
set [self] . [flag_c] to <(((data::custom) >> [0]) and [1])>
return (array2 (runtime  var [self]) [null])

define P_push_byte(self) (data) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
change [self] . [stack_pointer] within 8 bits by [-1]
set [self] . [memory] to (M___setitem__  (get [self] . [memory]) ([256] + (get [self] . [stack_pointer])) (data::custom)  )
return (array2 (runtime  var [self]) [null])

define P_push_word(self) (data) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
if <(BYTEORDER) = [little]> then
    set runtime var [value1] to ((data::custom) and [255])
    set runtime var [value2] to (((data::custom) >> [8]) and [255])
else
    set runtime var [value1] to (((data::custom) >> [8]) and [255])
    set runtime var [value2] to ((data::custom) and [255])
end
set2 [self] [_] to (P_push_byte (runtime var [self]) (runtime var [value1]))
set2 [self] [_] to (P_push_byte (runtime var [self]) (runtime var [value2]))
return (array2 (runtime  var [self]) [null])

define P_pop_byte(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set runtime var [data] to (M___getitem__ (get [self] . [memory]) ([256] + (get [self] . [stack_pointer])))
change [self] . [stack_pointer] within 8 bits by [1]
return (array2 (runtime  var [self]) (runtime var [data]))

define P_pop_word(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [t1] to (P_pop_byte (runtime var [self]))
set2 [self] [t2] to (P_pop_byte (runtime var [self]))
if <(BYTEORDER) = [little]> then
    set runtime var [data] to (((runtime var [t1]) \<\< [8]) or (runtime var [t2]))
else
    set runtime var [data] to ((runtime var [t1]) or ((runtime var [t2]) \<\< [8]))
end
return (array2 (runtime  var [self]) (runtime var [data])) //{"newRow":true}


define P_evaluate_flag_n(self) (data) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set [self] . [flag_n] to <((data::custom) and [128])>
return (array2 (runtime  var [self]) [null])

define P_evaluate_flag_z(self) (data) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set [self] . [flag_z] to <(data::custom) = [0]>
return (array2 (runtime  var [self]) [null])

define P_evaluate_flags_nz(self) (data) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [_] to (P_evaluate_flag_n (runtime var [self]) (data::custom))
set2 [self] [_] to (P_evaluate_flag_z (runtime var [self]) (data::custom))
return (array2 (runtime  var [self]) [null])

define P_evaluate_flags_nz_a(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [_] to (P_evaluate_flags_nz (runtime var [self]) (get [self] . [reg_a]))
return (array2 (runtime  var [self]) [null])

define P_evaluate_flags_nz_x(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [_] to (P_evaluate_flags_nz (runtime var [self]) (get [self] . [reg_x]))
return (array2 (runtime  var [self]) [null])

define P_evaluate_flags_nz_y(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [_] to (P_evaluate_flags_nz (runtime var [self]) (get [self] . [reg_y]))
return (array2 (runtime  var [self]) [null]) //{"newRow":true}

define P_execute(self) (instructions) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
while <(get [self] . [instructions]) < (instructions::custom)>
    set2 [self] [opcode_num] to (P_fetch_byte (runtime var [self]))
    set runtime var [opcode] to ((in array (OPCODES) get (runtime var [opcode_num])) to [lowercase v])
    set runtime var [addressing_mode] to ((in array (ADDRESSING) get (runtime var [opcode_num])) to [lowercase v])
    if <(runtime var [opcode]) = [   ]> then
        set runtime var [opcode] to [nop]
        set runtime var [addressing_mode] to [imp]
    end
    set runtime var [instr_func] to (join [P_ins_] (runtime var [opcode]))
    if <  <(runtime var [addressing_mode]) = [imp]> or <array [\["JMP", "JSR"\]] contains (runtime var [opcode])>  > then
        set runtime var [func_args] to (array2 (runtime var [self]) (runtime var [addressing_mode]))
    else
        set runtime var [addressing_func] to (join [P_addressing_] (runtime var [addressing_mode]))
        set3 [self] [operand] [args] to (call_with (runtime var [addressing_func]) (array1 (runtime var [self])))
        set runtime var [func_args] to (array3 (runtime var [self]) (runtime var [addressing_mode]) (runtime var [operand]))
        set runtime var [func_args] to (add items from array (runtime var [args]) to array (runtime var [func_args]))
    end
    set2 [self] [_] to (call_with (runtime var [instr_func]) (runtime var [func_args]))
    change [self] . [instructions] by [1]
end
return (array2 (runtime var [self]) [null]) //{"newRow":true}


define P_addressing_imm(self) //{"blockType":"textReporter","comment":"Addressing for the MOT-6502"}
set runtime var [self] to (self::custom)
set2 [self] [operand] to (P_fetch_byte (runtime var [self]))
return (array3 (runtime var [self]) (runtime var [operand]) [\[\]])

define P_addressing_zp(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [address] to (P_fetch_byte (runtime var [self]))
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_zpx(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [base_address] to (P_fetch_byte (runtime var [self]))
set runtime var [address] to (((runtime var [base_address]) + (get [self] . [reg_x])) and [255])
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_zpy(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [base_address] to (P_fetch_byte (runtime var [self]))
set runtime var [address] to (((runtime var [base_address]) + (get [self] . [reg_y])) and [255])
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_abs(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [address] to (P_fetch_word (runtime var [self]))
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_abx(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [base_address] to (P_fetch_word (runtime var [self]))
set runtime var [address] to (((runtime var [base_address]) + (get [self] . [reg_x])) and [65535])
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_aby(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [base_address] to (P_fetch_word (runtime var [self]))
set runtime var [address] to (((runtime var [base_address]) + (get [self] . [reg_y])) and [65535])
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_ind(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [address] to (P_fetch_word (runtime var [self]))
set2 [self] [operand] to (P_read_word (runtime var [self]) (runtime var [address]) <false>)
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [address]))  )

define P_addressing_inx(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [base_address] to (P_fetch_byte (runtime var [self]))
set runtime var [zp_address] to (((runtime var [base_address]) + (get [self] . [reg_x])) and [255])
set2 [self] [final_address] to (P_read_word (runtime var [self]) (runtime var [zp_address]) <false>)
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [final_address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [final_address]))  )

define P_addressing_iny(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [base_address] to (P_fetch_byte (runtime var [self]))
set2 [self] [zp_address] to (P_read_word (runtime var [self]) (runtime var [base_address]) <false>)
set runtime var [final_address] to (((runtime var [zp_address]) + (get [self] . [reg_y])) and [65535])
set2 [self] [operand] to (P_read_byte (runtime var [self]) (runtime var [final_address]))
return (  array3 (runtime var [self]) (runtime var [operand]) (array1 (runtime var [final_address]))  )

define P_addressing_rel(self) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [operand] to (P_fetch_byte (runtime var [self]))
return (array3 (runtime var [self]) (runtime var [operand]) [\[\]])

define P_addressing_acc(self) //{"blockType":"textReporter"}
return (array3 (runtime var [self]) (get [self] . [reg_a]) [\[\]]) //{"newRow":true}


define call_with (func_name) (args) //{"blockType":"textReporter","comment":"Subroutines for the MOT-6502"}
set4 [arg0] [arg1] [arg2] [arg3] to (args::custom)
switch (func_name::custom)
    case [P_addressing_imm]
        return (P_addressing_imm (runtime var [arg0]))
    end
    case [P_addressing_zp]
        return (P_addressing_zp  (runtime var [arg0]))
    end
    case [P_addressing_zpx]
        return (P_addressing_zpx (runtime var [arg0]))
    end
    case [P_addressing_zpy]
        return (P_addressing_zpy (runtime var [arg0]))
    end
    case [P_addressing_abs]
        return (P_addressing_abs (runtime var [arg0]))
    end
    case [P_addressing_abx]
        return (P_addressing_abx (runtime var [arg0]))
    end
    case [P_addressing_aby]
        return (P_addressing_aby (runtime var [arg0]))
    end
    case [P_addressing_ind]
        return (P_addressing_ind (runtime var [arg0]))
    end
    case [P_addressing_inx]
        return (P_addressing_inx (runtime var [arg0]))
    end
    case [P_addressing_iny]
        return (P_addressing_iny (runtime var [arg0]))
    end
    case [P_addressing_rel]
        return (P_addressing_rel (runtime var [arg0]))
    end
    case [P_addressing_acc]
        return (P_addressing_acc (runtime var [arg0]))
    end
end
set runtime var [instr_name] to (in (func_name::custom) replace first [P_ins_] with [])
return (P_instruction (runtime var [instr_name]) (runtime var [arg0]) (runtime var [arg1]) (runtime var [arg2]) (runtime var [arg3]))

define P_instruction (instr_name) (self) (mode) (operand) (address) //{"blockType":"textReporter","comment":"MOT-6502 Instructions."}
set runtime var [self] to (self::custom)
switch (instr_name::custom)
    case [nop] // Just chill
    end
    case [adc]
        set2 [self] [_] to (P_instr_adc (runtime var [self]) (mode::custom) (operand::custom) (address::custom))
    end
    case [and]
        set [self] . [reg_a] to ((get [self] . [reg_a]) and (operand::custom))
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
    case [asl]
        set [self] . [flag_c] to <((operand::custom) and [128])>
        set runtime var [result] to ((operand::custom) \<\< [1])
        if <(mode::custom) = [acc]> then
            set [self] . [reg_a] to (runtime var [result])
        else
            set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (runtime var [result]))
        end
        set2 [self] [_] to (P_evaluate_flags_nz (runtime var [self]) (runtime var [result]))
    end
    case [bcc]
        if <not <(get [self] . [flag_c])>> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [bcs]
        if <(get [self] . [flag_c])> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [beq]
        if <(get [self] . [flag_z])> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [bit]
        set [self] . [flag_n] to <((get [self] . [reg_a]) and [128])>
        set [self] . [flag_v] to <((get [self] . [reg_a]) and [64])>
        set [self] . [flag_z] to <((get [self] . [reg_a]) and (operand::custom)) = [0]>
    end
    case [bmi]
        if <(get [self] . [flag_n])> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [bne]
        if <not <(get [self] . [flag_z])>> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [bpl]
        if <not <(get [self] . [flag_n])>> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [brk]
        set2 [self] [_] to (P_instr_brk (runtime var [self]) (mode::custom) (operand::custom) (address::custom))
    end
    case [bvc]
        if <not <(get [self] . [flag_v])>> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [bvs]
        if <(get [self] . [flag_v])> then
            change [self] . [program_counter] within 16 bits by (help_twos_complement (operand::custom))
        end
    end
    case [clc]
        set [self] . [flag_c] to <false>
    end
    case [cld]
        set [self] . [flag_d] to <false>
    end
    case [cli]
        set [self] . [flag_i] to <false>
    end
    case [clv]
        set [self] . [flag_v] to <false>
    end
    case [cmp]
        set2 [self] [_] to (P_evaluate_flags_nz  (runtime var [self]) ((get [self] . [reg_a]) - (operand::custom))  )
        set [self] . [flag_c] to <help_is_greater_equal  (get [self] . [reg_a]) (operand::custom) <(get [self] . [flag_d])>  >
    end
    case [cpx]
        set2 [self] [_] to (P_evaluate_flags_nz  (runtime var [self]) ((get [self] . [reg_x]) - (operand::custom))  )
        set [self] . [flag_c] to <help_is_greater_equal  (get [self] . [reg_x]) (operand::custom) <(get [self] . [flag_d])>  >
    end
    case [cpy]
        set2 [self] [_] to (P_evaluate_flags_nz  (runtime var [self]) ((get [self] . [reg_y]) - (operand::custom))  )
        set [self] . [flag_c] to <help_is_greater_equal  (get [self] . [reg_y]) (operand::custom) <(get [self] . [flag_d])>  >
    end
    case [dec]
        set2 [self] [_] to (P_write_byte  (runtime var [self]) (address::custom) (((operand::custom) - [1]) and [255])  )
        set2 [self] [_] to (P_evaluate_flags_nz  (runtime var [self]) (((operand::custom) - [1]) and [255])  )
    end
    case [dex]
        change [self] . [reg_x] within 8 bits by [-1]
        set2 [self] [_] to (P_evaluate_flags_nz_x (runtime var [self]))
    end
    case [dey]
        change [self] . [reg_y] within 8 bits by [-1]
        set2 [self] [_] to (P_evaluate_flags_nz_y (runtime var [self]))
    end
    case [eor]
        set [self] . [reg_a] to ((get [self] . [reg_a]) xor (operand::custom))
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
    case [inc]
        set2 [self] [_] to (P_write_byte  (runtime var [self]) (address::custom) (((operand::custom) + [1]) and [255])  )
        set2 [self] [_] to (P_evaluate_flags_nz  (runtime var [self]) (((operand::custom) + [1]) and [255])  )
    end
    case [inx]
        change [self] . [reg_x] within 8 bits by [1]
        set2 [self] [_] to (P_evaluate_flags_nz_x (runtime var [self]))
    end
    case [iny]
        change [self] . [reg_y] within 8 bits by [1]
        set2 [self] [_] to (P_evaluate_flags_nz_y (runtime var [self]))
    end
    case [jmp]
        switch (mode::custom)
            case [abs]
                set [self] . [program_counter] to (address::custom)
            end
            case [ind]
                set [self] . [program_counter] to (operand::custom)
            end
        end
    end
    case [jsr]
        switch (mode::custom)
            case [abs]
                set2 [self] [program_counter] to (P_fetch_word (runtime var [self]))
            end
        end
        set2 [self] [_] to (P_push_word (runtime var [self]) (get [self] . [program_counter]))
        set [self] . [program_counter] to (runtime var [program_counter])
    end
    case [lda]
        set [self] . [reg_a] to (operand::custom)
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
    case [ldx]
        set [self] . [reg_x] to (operand::custom)
        set2 [self] [_] to (P_evaluate_flags_nz_x (runtime var [self]))
    end
    case [ldy]
        set [self] . [reg_y] to (operand::custom)
        set2 [self] [_] to (P_evaluate_flags_nz_y (runtime var [self]))
    end
    case [lsr]
        set [self] . [flag_c] to <((operand::custom) and [1])>
        set runtime var [result] to ((operand::custom) >> [1])
        if <(mode::custom) = [acc]> then
            set [self] . [reg_a] to (runtime var [result])
        else
            set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (runtime var [result]))
        end
        set2 [self] [_] to (P_evaluate_flag_z (runtime var [self]) (runtime var [result]))
    end
    case [ora]
        set [self] . [reg_a] to ((get [self] . [reg_a]) or (operand::custom))
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
    case [pha]
        set2 [self] [_] to (P_push_byte (runtime var [self]) (get [self] . [reg_a]))
    end
    case [php]
        set2 [self] [status_register] to (P_read_flags_register (runtime var [self]) <true>)
        set2 [self] [_] to (P_push_byte (runtime var [self]) (runtime var [status_register]))
    end
    case [pla]
        set2 [self] [acc] to (P_pop_byte (runtime var [self]))
        set [self] . [reg_a] to (runtime var [acc])
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
    case [plp]
        set2 [self] [status_register] to (P_pop_byte (runtime var [self]))
        set2 [self] [_] to (P_set_flags_register (runtime var [self]) (runtime var [status_register]))
    end
    case [rol]
        set runtime var [result] to ((((operand::custom) \<\< [1]) and [255]) or (get [self] . [flag_c]))
        set [self] . [flag_c] to <((operand::custom) and [128])>
        if <(mode::custom) = [acc]> then
            set [self] . [reg_a] to (runtime var [result])
        else
            set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (runtime var [result]))
        end
        set2 [self] [_] to (P_evaluate_flags_nz (runtime var [self]) (runtime var [result]))
    end
    case [ror]
        set runtime var [result] to (((get [self] . [flag_c]) \<\< [7]) or ((operand::custom) >> [1]))
        set [self] . [flag_c] to <((operand::custom) and [1])>
        if <(mode::custom) = [acc]> then
            set [self] . [reg_a] to (runtime var [result])
        else
            set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (runtime var [result]))
        end
        set2 [self] [_] to (P_evaluate_flags_nz (runtime var [self]) (runtime var [result]))
    end
    case [rti]
        set2 [self] [status_register] to (P_pop_byte (runtime var [self]))
        set2 [self] [_] to (P_set_flags_register (runtime var [self]) (runtime var [status_register]))
        set2 [self] [program_counter] to (P_pop_word (runtime var [self]))
        set [self] . [program_counter] to (runtime var [program_counter])
    end
    case [rts]
        set2 [self] [return_address] to (P_pop_word (runtime var [self]))
        set [self] . [program_counter] to (((runtime var [return_address]) + [1]) and [65535])
    end
    case [sbc]
        set2 [self] [_] to (P_instr_sbc (runtime var [self]) (mode::custom) (operand::custom) (address::custom))
    end
    case [sec]
        set [self] . [flag_c] to <true>
    end
    case [sed]
        set [self] . [flag_d] to <true>
    end
    case [sei]
        set [self] . [flag_i] to <true>
    end
    case [sta]
        set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (get [self] . [reg_a]))
    end
    case [stx]
        set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (get [self] . [reg_x]))
    end
    case [sty]
        set2 [self] [_]  to (P_write_byte (runtime var [self]) (address::custom) (get [self] . [reg_y]))
    end
    case [tax]
        set [self] . [reg_x] to (get [self] . [reg_a])
        set2 [self] [_] to (P_evaluate_flags_nz_x (runtime var [self]))
    end
    case [tay]
        set [self] . [reg_y] to (get [self] . [reg_a])
        set2 [self] [_] to (P_evaluate_flags_nz_y (runtime var [self]))
    end
    case [tsx]
        set [self] . [reg_x] to (get [self] . [stack_pointer])
        set2 [self] [_] to (P_evaluate_flags_nz_x (runtime var [self]))
    end
    case [txa]
        set [self] . [reg_a] to (get [self] . [reg_x])
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
    case [txs]
        set [self] . [stack_pointer] to (get [self] . [reg_x])
    end
    case [tya]
        set [self] . [reg_a] to (get [self] . [reg_y])
        set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
    end
end
return (array2 (runtime var [self]) [null]) //{"blockType":"booleanReporter"}

define P_instr_adc(self) (mode) (operand) (address) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
if <(get [self] . [flag_d])> then
    set runtime var [low_nibble] to (  (((get [self] . [reg_a]) and [15]) + ((operand::custom) and [15])) + (get [self] . [flag_c])  )
    set runtime var [high_nibble] to (  ((get [self] . [reg_a]) >> [4]) + ((operand::custom) >> [4])  )
    if <(runtime var [low_nibble]) > [9]> then
        change runtime var [low_nibble] by [-10]
        change runtime var [high_nibble] by [1]
    end
    if <(runtime var [high_nibble]) > [9]> then
        change runtime var [high_nibble] by [-10]
        set [self] . [flag_c] to <true>
    else
        set [self] . [flag_c] to <false>
    end
    set runtime var [final_result] to (((runtime var [low_nibble]) \<\< [4]) or (runtime var [low_nibble]))
else
    set runtime var [intermediary_result] to (  ((get [self] . [reg_a]) + (operand::custom)) + (get [self] . [flag_c])  )
    set runtime var [final_result] to ((runtime var [intermediary_result]) and (255))
    set [self] . [flag_c] to <(runtime var [intermediary_result]) > [255]>
end
set [self] . [flag_v] to <((  ((get [self] . [reg_a]) xor (operand::custom))  and  ((get [self] . [reg_a]) xor (runtime var [final_result]))  ) and [128])>
set [self] . [reg_a] to (runtime var [final_result])
set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
return (array2 (runtime var [self]) [null])

define P_instr_sbc(self) (mode) (operand) (address) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
if <(get [self] . [flag_d])> then
    set runtime var [low_nibble] to (  (((get [self] . [reg_a]) and [15]) - ((operand::custom) and [15])) - <not <(get [self] . [flag_c])>>  )
    set runtime var [high_nibble] to (  ((get [self] . [reg_a]) >> [4]) - ((operand::custom) >> [4])  )
    if <(runtime var [low_nibble]) < [0]> then
        change runtime var [low_nibble] by [10]
        change runtime var [high_nibble] by [-1]
    end
    if <(runtime var [high_nibble]) < [0]> then
        change runtime var [high_nibble] by [10]
        set [self] . [flag_c] to <false>
    else
        set [self] . [flag_c] to <true>
    end
    set runtime var [final_result] to (((runtime var [low_nibble]) \<\< [4]) or (runtime var [low_nibble]))
else
    set runtime var [intermediary_result] to (  ((get [self] . [reg_a]) - (operand::custom)) - <not <(get [self] . [flag_c])>>  )
    set runtime var [final_result] to ((runtime var [intermediary_result]) and (255))
    set [self] . [flag_c] to <not <(runtime var [intermediary_result]) < [0]>>
end
set [self] . [flag_v] to <((  ((get [self] . [reg_a]) xor (operand::custom))  and  ((get [self] . [reg_a]) xor (runtime var [final_result]))  ) and [128])>
set [self] . [reg_a] to (runtime var [final_result])
set2 [self] [_] to (P_evaluate_flags_nz_a (runtime var [self]))
return (array2 (runtime var [self]) [null])

define P_instr_brk(self) (mode) (operand) (address) //{"blockType":"textReporter"}
set runtime var [self] to (self::custom)
set2 [self] [_] to (P_push_word (runtime var [self]) (get [self] . [program_counter]))
set2 [self] [status_register] to (P_read_flags_register (runtime var [self]) <true>)
set2 [self] [_] to (P_push_byte (runtime var [self]) (runtime var [status_register]))
set2 [self] [pc] to (P_read_word (runtime var [self]) [65534] <false>)
set [self] . [program_counter] to (runtime var [pc])
set [self] . [flag_i] to <true>
return (array2 (runtime var [self]) [null])
